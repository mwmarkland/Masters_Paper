\section{The Type System}
\label{typesystem}
The type system for Larch/C++ is built upon the type systems of LSL
and C++. The process of building a type system involves defining how
the language is scoped, how individual terms are assigned types, and
how the statements and expressions type check. \emph{Scoping} is a
description of the visibility of identifiers. The Larch/C++ type
system bases its assignment of types and rules for type checking
expressions and statements more on the LSL type system, while the
scoping rules are based upon those of C++. This leads to an
interesting algorithm for looking up variables.

Recall that the terms sort and type, and the corresponding
sort checking and type checking, are used interchangeably throughout
this paper.

\subsection{The LSL Type System}
\label{lslts}
As mentioned earlier in Section~\ref{lslintro} the basic unit of
structure in LSL is the trait. Traits are used to define sorts and
their associated operations, which exhibit uniform behavior under
their associated operations.

Since the Larch/C++ language depends upon LSL to supply
abstractions, it was important to learn how the LSL type system
works. Unfortunately, little has been written on the LSL type
system. Neither the technical report on LSL
\cite{Guttag-Horning-Modet90} nor the Larch book \cite{Guttag-Horning93}
offered any details. What was available was the LSL Checker
\cite{LSLChecker}. The LSL Checker is a tool that will perform semantic and
syntactic checks on LSL traits. Since the LSL Checker provides type
checking of traits, it serves as an operational definition of the
LSL type system. Given this definition, information about the type
system could be generated by running the Checker on example
traits. One option of the LSL Checker that assisted in the development
of the traits, and the initial ideas about the system was its \reserved{-syms}
option. This option will cause the LSL Checker to produce a list of
the operators and their signatures contained within the LSL trait. An
example of this output, generated by the command line \reserved{lsl
-syms Example1.lsl} is illustrated in Figure~\ref{symsoutput} (Note:
this is only a portion of the actual output). Please refer to
Figure~\ref{lslex1} for the trait \reserved{Example1.lsl}, which
generated this output. 
\begin{BFIGURE}
\begin{verbatim}
if __ then __ else __: Bool, Bool, Bool -> Bool
if __ then __ else __: Bool, Int, Int -> Int
if __ then __ else __: Bool, int, int -> int
if __ then __ else __: Bool, float, float -> float
true: -> Bool
false: -> Bool
x: -> int
y: -> Bool
f: int -> float
f: int -> Bool
g: Bool -> float
q: int, Bool -> Bool
q: int, Bool -> float
...
\end{verbatim}
\caption{Partial output from the \reserved{lsl -syms} command}
\label{symsoutput}
\end{BFIGURE}

Each line of the \reserved{-syms} output consists of a operator
name and an associated signature for that operator; these parts are separated by a
colon. In the example above, there is an operator named \reserved{x}
which takes no input and returns an item of sort \reserved{->int}. There
are also operators such as \reserved{f}, which have two different
signatures. The ability of an operator to have more than one distinct
signature is an example of overloading.\emph{Overloading} occurs when a
given name can simultaneously stand for multiple, distinct
functions. 

After examining the \reserved{-syms} output it was clear that LSL
supported overloading. However, the extent of LSL's overloading and its
overload resolution techniques were still unknown. A series of traits
were created that used different sets of functions and the built-in
\texttt{if-then-else} LSL operator. The \texttt{if-then-else} operator
was chosen because it was built-in, because it allowed for
experimentation with types that might not be numeric, and because it
requires the
\reserved{then} and \reserved{else} clauses to have the same unique
sort. The LSL Checker was run on the traits to see what kind of errors,
if any, it found.

\begin{BFIGURE}
\begin{verbatim}
Example1:trait

   includes Integer

   introduces
        x: -> int
        y: -> Bool
        f: int->float
        f: int->Bool
        g: Bool->float
        q: int,Bool->Bool
        q: int,Bool->float

   asserts
        \forall a:int,b:Bool
        q(a,b) == if true then f(a) else g(b);
\end{verbatim}
\caption{Example1.lsl}
\label{lslex1}
\end{BFIGURE}

Figure~\ref{lslex1} is an example of an LSL trait that successfully
sort checks. Working under the assumption that terms could carry sets
of sorts, this trait sort checks in the following way. The term
\reserved{q(a,b)} has the set of sorts
\{\reserved{Bool},\reserved{float}\} associated with it. Similarly the
term \reserved{f(a)} has the set
\{\reserved{float},\reserved{Bool}\}, and the term \reserved{g(b)}
has the set \{\reserved{float}\}. Since the
\reserved{if-then-else} function requires the \reserved{then} and
\reserved{else} clauses to have the same sort, the
resulting sort of this operator must be \reserved{float}. This
illustrates an important point. In this case, the system chooses the
version of operator \reserved{f} that it will use in the type checking
based upon what it needs in the context of the \reserved{if-then-else}
operator. In this case, by choosing the intersection
of the two sets, the LSL Checker chooses to use \reserved{f:int -> float} because it
works in the context where \reserved{g(b)} only has one sort. This is an
example of context-dependent overload
resolution. \emph{Context-dependent overloading} means that the
context in which the function or variable appears is used to help uniquely identify
its sort \cite{Watt90}. Finally, since both sides of the \reserved{==}
operator have a sort in common, and it is known from the
\reserved{-syms} output that it requires equivalent sorts for its
arguments, the expression sort checks. 

\begin{BFIGURE}
\begin{verbatim}
Example2:trait

   includes Integer
   introduces
        x: -> int
        y: -> Bool
        f: int->int
        f: int->Bool
        f: int->E
        g: Bool->float
        q: int,Bool->Bool
        q: int,Bool->float

   asserts
     \forall a:int,b:Bool
        q(a,b) == if true then f(a) else g(b);
\end{verbatim}
\caption{Example2.lsl}
\label{lslex2}
\end{BFIGURE}

Figure~\ref{lslex2} illustrates a situation where the trait will not
sort check. This trait was designed with the purpose of confirming the
assumption made in the above example: that all terms may have sets of
sorts associated with them.

\begin{verbatim}
./Example2.lsl:16: (near col 18): `if __ then __ else __' not 
declared with matching domain sorts
        Possible sorts for arg 1: Bool
        Possible sorts for arg 2: int, Bool, E
        Possible sorts for arg 3: float
Abort: error in checking LSL traits
\end{verbatim}

The output from the LSL Checker for this trait describes the possible
sorts available for the arguments to the \reserved{if-then-else}
operation. In this case note that arg 2, which is \reserved{f(a)}, has
three possible sorts. The sort checking error also shows that there
must be an intersection between the sets of the arguments for the
operator to sort check. In this case there is an empty intersection between
\reserved{f(a)}'s set \{\reserved{int}, \reserved{Bool}, \reserved{E}\}
and \reserved{g(b)}'s set \{\reserved{float}\}. This leads to the
error condition.

\begin{BFIGURE}
\begin{verbatim}
Example3:trait
   includes Integer

   introduces
        x: -> int
        y: -> Bool
        f: int->int
        f: int->Bool
        f: int->E
        g: Bool->float
        g: Bool->int
        g: Bool->E
        q: int,Bool->Bool
        q: int,Bool->float

   asserts
     \forall a:int,b:Bool
        q(a,b) == if true then f(a) else g(b);
\end{verbatim}
\caption{Example3.lsl}
\label{lslex3}
\end{BFIGURE}

To follow up on the previous examples, a trait was created to see if
similar errors could be generated with other operators. This trait is
shown in Figure~\ref{lslex3}. 
\begin{verbatim}
./Example3.lsl:18: (near col 8): `q' sorts of terms in equation 
do not match
        Possible sorts for left side: Bool, float
        Possible sorts for right side: int, E
Abort: error in checking LSL traits
\end{verbatim}

\noindent This error shows that the sort associated with the
\reserved{if-then-else} operator is the set consisting of
\{\reserved{int}, \reserved{E}\}. So, the LSL Checker will try to find
a sort for \reserved{q(a,b)} that would fit the constraint that
operator \reserved{==} needs to have the same sort for each
argument. In this case, since \reserved{q(a,b)} has the set
\{\reserved{Bool},\reserved{float}\} associated with it, there is no
possible solution.

\begin{BFIGURE}
\begin{verbatim}
Example4:trait
   introduces
        x: int->int
        x: int->float
        y: int->int
        y: int->float
        p: int,int->int
        p: int,int->float

   asserts
     \forall a,b:int
        p(a,b) == if (a=b) then x(a) else y(a)
\end{verbatim}
\caption{Example4.lsl}
\label{lslex4}
\end{BFIGURE}

The previous examples have shown that for an operator like
\reserved{==} to sort check, there needs to be a non-empty intersection between
the sets of sorts for its arguments. What if that set has a
cardinality larger than one? Figure~\ref{lslex4} is an example where
the intersection between the sets of sorts for the arguments to
\reserved{==} does not have an intersection of cardinality one. This
generates the following output from the LSL Checker.
\newpage

\begin{verbatim}
./Example4.lsl:12: (near col 8): `p' more than one possible 
sort for terms in equation 
Possible sorts: int, float 
Abort: error in checking LSL traits
\end{verbatim}

\noindent Since the intersection is not of cardinality one, the
expression does not sort check.

\begin{BFIGURE}
\begin{verbatim}
foo:trait

includes Integer

introduces
  x: -> int
  y: -> Bool
  f: int->float
  f: int->Bool
  g: Bool->float
  q: int,Bool->Bool
  q: int,Bool->float

asserts
 \forall x:int,b:Bool
    q(x,b) == if true then f(x) else g(b);
\end{verbatim}
\caption{A LSL Trait with an error in the declaration of variables}
\label{quanttrait}
\end{BFIGURE}

Another property of the LSL type system is that any variables declared
must have completely unique names. For example the trait in
Figure~\ref{quanttrait} causes the following error to be issued by the
LSL Checker:

\begin{verbatim}
./foo.lsl:15: (near col 9): `x' variable duplicates constant 
of same sort
Abort: error in checking LSL traits
\end{verbatim}

\noindent Notice how the \reserved{x:int} declaration within the
\verb+\+\texttt{forall} expression interferes with the \reserved{x: ->int}
declaration in the \reserved{introduces} section. This error occurs
because of constraints placed upon the output the LSL Checker
generates for the Larch Prover. 


The results of these experiments with the LSL Checker can be
summarized as follows:

\begin{itemize}
\item LSL terms have non-empty sets of sorts associated with them. 
\item The elements in a LSL term's set of sorts may be dependent on
the context in which the term is used.
\item When checking is complete, every expression or equation
should have a single sort. If this does not occur, there is a type error.\item Declared variables should have unique names.
\end{itemize}

\noindent When the system sort checks, there will be sets of sorts
associated with the various terms. As the sort checking progresses,
these sets will be narrowed by the contextual information until every
expression has an assigned, singular sort, or has sort checked.

The other major issue in type systems is scoping. Scoping has few
complications in LSL. There are two scopes, the global scope and
quantifier scope. All names go into the global scope, with the
appropriate overloading, unless they are declared in a quantified
expression. 


\begin{BFIGURE}
\begin{verbatim}
asserts
  \forall x:E, s1:Set, s2:Set

   s1 \subset s2 == \A x (x \in s1 => x \in s2) /\ s1 \neq s2

\end{verbatim}
\caption{An example of quantifier scope.}
\label{quantscope}
\end{BFIGURE}

An example of the creation of quantifier scope is shown in
Figure~\ref{quantscope}. This example shows a portion of a LSL trait
which describes Sets. Notice that the definition of the
\verb+\+\reserved{subset} function contains a quantified
expression of the form \verb+\+\reserved{A x ( $\dots$ )}. The scope
of \reserved{x} is the text between the parentheses. 


\subsection{The C++ Type System}
\label{cppts}
This section gives a brief overview of the C++ type
system. Although not a complete description, it should serve as an
introduction for people unfamiliar with it. The section is based upon the C++
Annotated Reference Manual \cite{Ellis-Stroustrup90} which should be
referred to for a complete description of the C++ type system.

The C++ type system is based upon the C type system with a few
additions. There are two broad categories of types, fundamental
types and derived types. \emph{Fundamental types} are the basic
building blocks of the type system. They consist of the types that are
built-in to the implementation. Examples are \reserved{int},
\reserved{float}, and \reserved{char}. \emph{Derived types} are types
built from the fundamental types or from other derived types. Examples of
these include arrays, functions, and classes. Type names can be
created via the \reserved{typedef} construct, which assigns a new name to
a previously existing type. 

C++ also offers a variety of polymorphic forms. These include
templates, static overloading, dynamic overloading, and subtype
polymorphism. Although these forms are important to the C++ type
system, with the exception of templates, they are not an important
part of the Larch/C++ type system. Thus it is beyond the scope of this
paper to describe them in more detail.

Templates in C++ let users create generic classes that can be
instantiated to support a specific type. A template allows the
programmer to pass types as parameters to a class. This structure is
an example of parametric polymorphism. \emph{Parametric polymorphism}
is when a set of operations require a type parameter that defines
their behavior.

Compared to LSL, C++ has a complex scope system. The innermost scope
level is local scope. \emph{Local} scope refers to the declarations
within a given block. Items declared with local scope are visible
within the block they are declared in. \emph{Function} scope refers to use of labels within
functions. \emph{Class} scope contains the names of all members, both
functions and variables, that are contained within a class
definition. Finally, \emph{file} scope refers to any declarations that
occur outside of all blocks and classes. Declarations at file scope
are visible within the given translation unit (usually the source
file).

In general, name lookup in C++ begins within the local scope and moves
outward to file scope. The process may be modified by using the scope
resolution (\reserved{::}) operator to state explicitly where to look for the
name. Names may also be hidden or overridden within given scopes. The
key idea is that even with the above features, C++ requires that any
use of a name be unambiguous within a given scope.

\subsection{The Larch/C++ Type System}
\label{lcppts}
\subsubsection{Overview}
The Larch/C++ language has its own unique type system. Though this
system has many things in common with both the LSL and C++ type
systems, Larch/C++ is its own language. Looking at the structure of a
Larch/C++ specification will help to explain the system and its
unique properties. Below is a specification for a simple C++ function
\reserved{increment} which increments a global variable
\reserved{x}. It is based upon the Counter trait shown in Figure~\ref{CounterTrait}.

\begin{verbatim}
  int i;
  void increment();
  //@ behavior {
  //@   requires value(i^) < Limit;
  //@   modifies i;
  //@   ensures  i' = inc(i^);
  //@ }
\end{verbatim}

\noindent Recall that this specification could be broken down into a
C++ portion and the actual Larch/C++ specification. In this case the line
\begin{verbatim}
  int i;
\end{verbatim}
is the C++ declaration for the variable \reserved{i}. The
Larch/C++ type system must be able to take this C++ declaration and
convert it into a binding of i to a sort. This sort can then be used later
when \reserved{i} is mentioned. 

The items set off by the \reserved{behavior} keyword are behavioral annotations. It is within this section that the
Larch/C++ system must do its type checking. Within this section, it is
not legal to call an actual C++ function. For example, it would be
illegal to write the following:
\begin{verbatim}
ensures self' = increment();
\end{verbatim}
Thus any terms within the specification that look like functions do not
refer to C++ functions, but rather to LSL operators defined either by
user traits or by the inherent traits for the system. This lack of C++
function calls in the specifications makes the type system simpler. It
does not have to understand the C++ concepts of static and dynamic
overload resolution. It does need to understand LSL operators,
though. Because of this, the Larch/C++ type system acts like the LSL
type system in that it supports operator overloading by creating sets
of sorts for operators, and it will attempt to determine the sorts for
expressions via contextual clues.

The basic notion of the Larch/C++ type system is that there is a
correspondence between C++ declarations and the LSL sorts. Larch/C++
creates this correspondence by having a set of basic sorts which correspond to
the fundamental types in C++. It also adds auxiliary sorts that allow
for the discussion of objects. The Larch/C++ Checker automatically has
these basic sorts available and uses them to convert C++ declarations
into equivalent sorts. Users may also define abstract values and
operations in their own traits. The user would place the trait in a
\reserved{uses} clause before using any theory from it. The
\reserved{uses} clause causes the Larch/C++ Checker to generate
information about the sorts and operations from the trait and make it
available to the rest of the specification.

The \reserved{uses} clause also supports the C++ template
facility. Since there is no equivalent to parametric polymorphism in
LSL, the \reserved{uses} clause, when combined with renaming, is used
to ``instantiate'' a trait with the correct sort. An example of this
is the \reserved{SimpleSet} specification from the Larch/C++ Manual, Section 8.2
\cite{Leavens96c}. Figure \ref{simpleset} is an example of this 
for a simple set class implemented via templates. There is one
template argument, a class \reserved{Elem}, which will be the elements
of the set. The specifier needs to create an abstract model that can
be used with this trait. The specifier creates the following
\reserved{uses} clause for this purpose.


\begin{BFIGURE}
\begin{verbatim}
// @(#)$Id: SimpleSet.lh,v 1.19 1997/06/03 20:29:52 leavens Exp $

template <class Elem>
  //@ expects contained_objects(Elem);
  //@ where Elem is {
  //@   bool operator ==(Elem x, Elem y);
  //@   behavior {
  //@       ensures returns /\ result = (x = y);
  //@   }
  //@ };
class Set {
public:
  //@ uses SimpleSetTrait(Elem for E, Set<Elem> for C);

  Set() throw();
  //@ behavior {
  //@   constructs self;
  //@   ensures liberally self' = empty;
  //@ }

  void insert(Elem e) throw();
  //@ behavior {
  //@   modifies self;
  //@   ensures liberally self' = self^ \U {e};
  //@ }

  bool is_in(Elem e) const throw();
  //@ behavior {
  //@   ensures result = (e \in self);
  //@ }
};
\end{verbatim}
\caption{SimpleSet.lh}
\label{simpleset}
\end{BFIGURE}


\begin{verbatim}
  //@ uses SimpleSetTrait(Elem for E, Set<Elem> for C);
\end{verbatim}

\noindent This \reserved{uses} clause has the effect of specializing the trait
so that the basic sorts are now \reserved{Elem} and
\reserved{Set[Elem]} (note that the translation of the \reserved{<>}
notation to the [] notation is done by the Larch/C++ Checker
automatically). This means that an LSL operation, such as
\reserved{empty}, which used to have a result sort of \reserved{C} now
has a result sort of \reserved{Set[Elem]}.

The other major complication in the Larch/C++ type system is the
scoping of identifiers and operators. Recall that the scoping system
in LSL is simpler than that of C++. Larch/C++ will build upon both of
these type systems to create its own. 

Larch/C++ expands the basic C++ scoping system by adding three new
scope units. \emph{Function-specification} scope refers to the area
inside of a specific function specification. It contains the
declarations for the function parameters, the function's
\reserved{result}, the keyword \reserved{self}, and any other
declarations found there. It is a specialization of the local scope from
C++. \emph{Spec-case} scope refers to the fact that in a specification
that has multiple cases, each case has its own local scope. This is
because each spec-case is essentially a miniature
function-specification. Finally, as in LSL, there is a
\emph{quantifier} scope. All information in Larch/C++ is scoped. This
means that the location of a declaration or a
\reserved{uses} clause may affect the visibility of certain identifiers.

The goal when looking up an identifier in a Larch/C++ specification is
to find a single, unambiguous type that is bound to a given identifier.
Larch/C++'s mix of both LSL and C++ declarations makes
for more complex insertion and lookup functions for identifiers. One
reason for the complexity is that information from C++ declarations
and information about LSL operations are kept in separate worlds
within a scope. This is done for two reasons:
\begin{itemize} 
\item it allows for name conflict resolution
\item it allows the system to simulate the overloading system present in LSL.
\end{itemize}
\noindent These two ideas are described in more detail below.

The Larch/C++ Checker attempts to insert all identifiers into the
symbol table as they would be in C++. This leads to LSL operations
being scoped as in C++. The insertion process also does name conflict
resolution. Name conflict resolution occurs when, in a given scope, a
name for a variable or operation tries to reside in both the C++ and
LSL worlds. This is not allowed. If this occurs, the offending LSL
trait operation is discarded from the symbol table, giving preference
to the C++ declaration. Figures~\ref{Problemtrait} and ~\ref{fooex}
illustrate a typical situation in Larch/C++ where name conflict
resolution is needed. Note that the trait defines two operators:
\reserved{x}, a zero-argument operator that generates an integer value, and
\reserved{iden}, which takes an argument and returns it. These
operators are then put to use in the specification of the function
\reserved{foo}. In the specification shown in Figure~\ref{fooex}, there
is no problem with conflicting names. The trait operations defined in
the trait are inserted into an outer scope. The argument \reserved{int
x} is placed within the function-specification scope. Thus, the two
versions of \reserved{x} are in different scopes. Since the type
system tries to find the most local match, it will choose the formal
parameter. 

Figure~\ref{fooex2} shows a specification very similar to the previous
one, except for a name conflict that is harder to resolve.  In this
case the two possibilities for \reserved{x}, the formal parameter and
the LSL operator, both exist within the function-specification scope. A
lookup algorithm that tries to find the most local identifier has a
problem; there are two good choices. One way of solving this
problem is to prioritize the worlds. The system would look in the
local C++ world first, then in the world containing the local trait
operations. If a conflict exists the Checker would always use the C++
name. Another possibility is to reverse the action, so that the the trait
operation is always chosen by the Checker.
The best choice, and the one implemented
in the Larch/C++ Checker, is to flag this as a type error. Once the
user has been informed, the system discards the trait operation that
has the name conflict. Once informed, the user may either ignore the
error, in which case the local identifier would in this example
resolve to the formal parameter, or the trait may be modified; renaming
the trait operation that causes the conflict. This would then allow
for both the trait operation and the local C++ declaration to
coexist. This solution is both flexible and has a default behavior
that makes sense.


\begin{BFIGURE}
\begin{verbatim}
Problem:trait
   includes Integer(int for Int)

   introduces
        x:->int
        iden:int->int

   asserts
     \forall i:int
        iden(i) == i;
\end{verbatim}
\caption{ProblemTrait.lsl}
\label{Problemtrait}
\end{BFIGURE}

\begin{BFIGURE}
\begin{verbatim}
//@ uses Problem;
int foo(int x);
//@ behavior {
//@ ensures result = iden(x);
//@}
\end{verbatim}
\caption{Function \reserved{foo}: version 1}
\label{fooex}
\end{BFIGURE}


\begin{BFIGURE}
\begin{verbatim}

int foo(int x);
//@ behavior {
//@ uses Problem;
//@ ensures result = iden(x);
//@}
\end{verbatim}
\caption{Function \reserved{foo}: version 2}
\label{fooex2}
\end{BFIGURE}

The discussion of name conflict resolution leads to another
important question: how are identifiers looked up in Larch/C++? As
mentioned earlier, the goal is to find the most local match, while
still offering the feel of ``global'' scope to the trait
operations. Recall from Section~\ref{lslts} that LSL operators are
overloaded. This means that one name may refer to multiple trait
operators. Recall also that the names of these operators all reside
in a single scope. The given operator name should be able to return
any of the possible overloads. In Larch/C++, the information on the
LSL operations is scoped. Thus a given name may only see overloads that
exist within its scope. This does not correctly match the LSL model, where
all the trait operations exist in a single global scope. The Larch/C++ name
lookup algorithm needs to simulate the LSL global scope or it may miss some
valid operations when sort checking. 

A first solution for name lookup might simply search up the symbol
table, finding all possible C++ and LSL operation identifiers that
match. This brute force solution leads to frequent name
conflict problems. Identifiers that should not even
be visible may be chosen as solutions, or may cause ambiguities. Other
possible solutions limit the search by matching the most local C++
identifier and matching all possible trait operations throughout the
symbol table. While this solution seems feasible it has the same flaw:
it may return an identifier that leads to an ambiguity.

The lookup algorithm chosen attempts to avoid finding ambiguous
identifiers by limiting the search in the trait operation side of the
table. The algorithm is illustrated in Figure~\ref{lookupalgm}.
\begin{BFIGURE}
\begin{verbatim}
Begin within the local scope.  
Look in the C++ world for an identifier with the correct name.

If a C++ identifier with the correct name is found, 
then return it and the search stops.

If a C++ identifier is not found, search the trait operation
world. If any identifier with the correct name is found, begin a
search in all enclosing scopes. 
This search is terminated by one of two conditions:

1. A C++ identifier with the correct name is seen. 
   Return the set of trait operations that has been generated.

2. The top of the symbol table is reached.
   Return the set of matching trait operations.

If no matching identifier is found in the local scope,
recurse on the next enclosing scope if it is valid. 

At the top of the table, return an error.

\end{verbatim}
\caption{The Larch/C++ name lookup algorithm}
\label{lookupalgm}
\end{BFIGURE}

This algorithm always locates the most local matching C++ declaration,
which it should do to model the C++ system, and always stops searching
the trait operations side at a point where name conflicts could
begin. The essence is that a C++ declaration ``shadows'' or hides all
possible trait operations of the same name in enclosing scopes. Thus,
the lookup of trait operations should stop when that shadowing
declaration is seen to avoid ambiguity. There will not
be any ambiguity at the point of the shadow declaration because of the
algorithm for name conflict resolution.

\subsubsection{Examples}
Here are some examples of how scoping and name lookup work in
Larch/C++. In these examples, the enclosing boxes represent the scope
boundaries for the various identifiers. Figure~\ref{scopetraits} shows
the simple traits that will be used in these examples. From our
previous LSL examples, recall that the LSL Checker allows constant
operators such as \reserved{x: -> int} to be used where a variable of
sort \reserved{int} is called for. Due to the fact that these may be
substituted for each other, the sort \reserved{int} will be used
as shorthand for either \reserved{int} or \reserved{->int} in the
following examples.


\begin{BFIGURE}
\begin{verbatim}
XTrait:trait
    introduces 
        x: -> int
        y: -> Bool

YTrait:trait
     introduces 
        y: -> int

fooTrait:trait
     introduces
        foo: int -> int
        y: -> float
\end{verbatim}
\caption{Example traits for scope and variable lookup examples}
\label{scopetraits}
\end{BFIGURE}

\begin{BFIGURE}
\begin{center}
\input{scopeex1}
\end{center}
\caption{Scope and variable lookup: example 1}
\label{scopeex1}
\end{BFIGURE}
Figure~\ref{scopeex1} shows a small example of a specification. The
goal is to build the sets of possible sorts for the variables
\reserved{x} and \reserved{y} and the operation \reserved{+}. The
process begins within the function-specifier scope represented by the
innermost box in the figure. The system attempts to find either a C++
declaration or a trait operation which is usable for \reserved{x}. As
there is no declaration for \reserved{x} there, it finds the formal
parameter declared by \reserved{int x} in the enclosing scope. At this
point, the search stops and the set of sorts for \reserved{x} is
\{\reserved{->int}\}.

The system continues by building the set of sorts for
\reserved{y}. Again it starts in the function-specifier scope. It does
not find a match in the two inner scopes. It moves to the next
enclosing scope, a class scope. Once in this scope, the search begins
within the C++ world. Again, no C++ declaration is found. The search
continues in the trait operation world. Here the system finds two
possibilities for \reserved{y}, either \reserved{->int} or \reserved{
->float}, which are provided by the traits \reserved{fooTrait} and \reserved{YTrait}
mentioned in the
\reserved{uses} clause. Since neither stopping condition holds, the search is continued into the enclosing scope. Here the
system finds a C++ declaration \reserved{int y}. Because of this, the
system stops searching and returns the set of sorts associated with the trait
operations that have been seen. 
This means that the
identifier
\reserved{y} has the set of sorts \{\reserved{->int,->float}\}. 


The search for the trait operation \reserved{+} occurs in a similar
fashion. In this case, the search goes to the top level of the symbol
table where the builtin sorts and their operations are inserted. The
system will have a set of possible signatures for \reserved{+} that come
both from the built-in traits and from whatever definitions of
\reserved{+} have been seen due to \reserved{uses} clauses. The system 
will try to find a signature that can be used with the set of types
for \reserved{x} and \reserved{y}. As seen above, the system knows
that the set of sorts for \reserved{x} is \{\reserved{int} and it
knows that knows that the set of sorts for \reserved{y} is
\{\reserved{->int, ->float}\}. So since there are no redefinitions
of \reserved{+}, in this case the system will end up searching the
built-in operations which are included at the highest level of the
symbol table structure. One of the signatures it finds is
\reserved{int,int ->int} (there would be others). In this case, the 
system would chose this signature for \reserved{+} because the
arguments to \reserved{+}, \reserved{x} and \reserved{y}, have the
sort \reserved{int} in their sets. 

Finally, note that this example would have generated a warning from
the Larch/C++ system. Within the outermost scope, there exists a
\reserved{uses} clause for \reserved{XTrait}, which has a definition of
\reserved{y}, and a C++ declaration of \reserved{y}. As the Larch/C++
Checker processes this file, it would first place the definition of
\reserved{y} from the \reserved{uses} clause into the LSL portion of
the symbol table. Then when it saw the C++ declaration for
\reserved{y}, it would use the rules for name conflict resolution
described earlier. In other words, it would discard the LSL operation
from the symbol table and issue a warning to the user. In this case,
the system would still be able to type check this
specification. However, in the general case, type checking results
when identifiers are discarded due to the name conflict resolution
system may be incomplete and possibly inaccurate.

\begin{BFIGURE}
\begin{center}
\input{scopeex2}
\end{center}
\caption{Scope and variable lookup: example 2}
\label{scopeex2}
\end{BFIGURE}

Figure~\ref{scopeex2} shows another small example of a
specification. This specification differs from the previous example in
that there is no declaration of the variable \reserved{y} in the outer
scope. As before, the set of sorts for \reserved{x} is \{\reserved{int}\}.

To build the set of sorts for
\reserved{y}, the system starts in the function-specifier scope. This
time, again, it does not find a match. It moves to the next
enclosing scope, a class scope. Once in this scope, the search begins
within the C++ world. Again, no C++ declaration is found. The
search continues in the trait operation world. Here the system
finds two possibilities for \reserved{y,} either \reserved{->int} or \reserved{
->float}, both of which are provided by the traits in the \reserved{uses}
clause. Since the stopping conditions were not met, the search
is continued into the enclosing scope. At the file scope, there is no
C++ declaration for \reserved{y}. So the system finds an trait
operation imported from \reserved{XTrait} that adds another
possibility to the set, \{\reserved{ ->Bool}\}. The system continues to
the next enclosing scope, realizes that it has reached the top of the
symbol table, and returns the set of sorts
\{\reserved{->int,->float,->Bool}\} for \reserved{y}. The search for the trait operation \reserved{+} is the same as in the
previous example.


\begin{BFIGURE}
\begin{center}
\input{scopeex3}
\end{center}
\caption{Scope and variable lookup: example 3}
\label{scopeex3}
\end{BFIGURE}

Figure~\ref{scopeex3} shows another small example of a
specification. This specification differs from the previous two in
that it contains a declaration that will cause a type error. Again,
the basic goal is to build the sets of possible sorts for the
variables
\reserved{x} and \reserved{y} and the operation \reserved{+}. The
process to build the set for \reserved{x} is the same as
the previous two examples.

The system continues by building the set of sorts for
\reserved{y}. As in the previous examples, it begins at the
function-specifier scope. Like the first example, a match is not
found in the two inner scopes. The system moves to the next enclosing
scope, a class scope. Once in this scope, the search begins within the
C++ world. Again, no C++ declaration is found. The search continues in
the trait operation world. Again, no match is found. The system
continues searching upward until it sees the \reserved{uses} clause at
the global scope. Here it finds a definition for \reserved{y} of
\reserved{ ->Bool}.  Since the system found trait operations that
match, the search is continued into the enclosing scope. However,
since this match for \reserved{y} is found in the outermost scope, the
system stops searching and returns the the set of sorts
\{\reserved{Bool}\}. This set will lead to a type error unless \reserved{+}
has the sort \reserved{int,Bool -> int}, which is unlikely. 

\subsubsection{Summary}
The Larch/C++ type system has the following qualities:

\begin{itemize}

\item Information for symbols is kept in two ``worlds.'' One portion
contains C++ declarations, the other contains LSL trait operations.

\item A scoping system similar to that of C++ which is applied to all
C++ and trait operation names.

\item A name conflict resolution algorithm which handles the case
where there exists a C++ declaration and a trait operation with the same
name in a given scope.

\item A name lookup algorithm that attempts to always give the most
local C++ declaration that is a match, and gives the illusion that the
trait operations are all stored within a single scope, while avoiding
the possibility of having an ambiguous solution (i.e. one where there
is both a trait operation and a C++ identifier that may be used).

\end{itemize}
